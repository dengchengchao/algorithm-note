### 插入排序

回顾第一节的情节，我们在对一堆打乱的扑克进行排序对的时候我们会直接选出最小的扑克放在最前面，再选出剩下元素中最小的，放在最前面，依次类推。

这样排序的时间复杂度为O(n^2)。有什么办法能够优化一下呢？

比如：6,7,3,2,1,8 ，如果不一一挑选出最小的数字，还有什么特点能够利用呢？

> 场景:当你玩斗地主的时候，假设每次拿到一张扑克牌，你都会保证手里的扑克牌是有序的，此时你手里已经有3,4,5,6,9 ，如果你又摸了一张7，为了保证扑克依然按顺序排列，你会怎样做？直接将7插入到6后面，扑克变为3,4,5,6,7,9

> 从拿到7到完成排序，其实我们只做了两次比较，7和9相比与6和7相比，发现6比7小，因此可以确定7应该放在6后面。为什么？

其实仔细想想就能知道，因为我们能确定，在6之前一定没有比7大的数存在，**因为原本的扑克牌是有序的**

这便是今天所要说的算法，插入排序。

比较一下插入排序和选择排序，我们会发现插入排序利用了数组原本的顺序以减少交换次数。

而这一切的基础便是，原本的数组需要是有序的。

比如对于：6,7,4,3,1,8

首先选前2个数字，维护他的有序性：6,7

保证前2位数字有序后，再对比第三位数字：6,7,4 -> 6,4,7 -> 4,6,7

保证前3位数字有序后，对比第四位数字：4,6,3,7 -> 4,3,6,7  -> 3,4,6,7

在对比第五位数字的时候，我们会发现第五位数字8比第四位数字7要大，因此就不必进行其他比较了，因为左边的数字都是由小到大排列：3,4,6,7,8

最后再对最后一位数字排序：3,4,6,7,8,1 -> 3,4,6,7,1,8 -> 3,4,6,1,7,8 -> 3,4,1,6,7,8 -> 3,1,4,6,7,8 -> 1,3,4,6,7,8

可以看到，插入排序的优点就在于利用了数组的原本顺序。

```java
    @Override
    public  void sort(int[] a) {
        final  int N=a.length;
        for (int i=1;i<N;i++){
            for (int j=i;j>=0 && a[j]<a[j-1];j--){ //一直移动到比它小的数的右边
                SortUtils.swap(a,j,j-1);
            }
        }
    }

```

代码比较简单，也是两层for循环，第一层循环遍历所有元素，第二层循环移动元素到合适的位置。比起第一篇所讲的插入排序来看，增加了一个提前结束循环的条件。

### 时间复杂度

**遍历时间**:上面分析，插入排序利用了元素原本的顺序，因此插入排序的时间复杂度会依据原本元素的情况而定，在极端的情况下，最好的时候为所有的元素都有序，也就是内层for循环一次都不执行，因此最好的时间复杂度为n-1≈O(n)，最坏的情况下为元素完全为反顺序。此时插入排序的时间复杂度和选择排序的时间复杂度相同,为(n-1)+(n-2)+(n-3)+...1=(n*(n-1))/2≈O(n^2)

**交换次数**:观察上面的代码我们可以发现，只要进入了内存for循环，都会执行交换操作，因此选择排序的交换次数和遍历时间正相关，具体次数为遍历次数T-(n-1)次。

### 稳定性

可以看到，插入排序是依次改变原本序列的有序性，当发现两个相同的元素，可以不进行交换，因此插入排序是稳定的。

### 总结

根据代码，我们可以分析一下插入排序的特性：

**核心**: 利用元素初始状态的一定区域的有序性来减少时间复杂度，因此性能在一般情况下比选择排序好。

**时间复杂度**:和数组原本的顺序有关，**最好为O(n),最坏为O(n^2)**

**稳定性**:稳定

总结表格如下

|     时间复杂度     | 空间复杂度 | 稳定性 |
| :----------------: | :--------: | :----: |
| 最好O(n)最坏O(n^2) |     1      |  稳定  |









