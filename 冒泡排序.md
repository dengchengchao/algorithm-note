### 冒泡排序

前面说到选择排序，由于选择排序的时间复杂度比较高，于是聪明的程序员经过不断的思考，想到一种优化途径：**利用数据原本的有序性**。

回想选择排序，两个`for`循环中，第二个`for`循环并没有都是从0开始，而是从`i`开始，为什么呢？因为我们能够确定，每经历一次内层循环，我们就能确定第`i-1`个元素是数组中最小的，因此下次循环便不必将其放入需要比较的序列中。

```java
  for (int i = 0; i < N; i++) {
            int min = i;//用来寻找集合中最小数字
            for (int j = i + 1; j < N; j++) {
                if (a[j]<a[min]) {
                    min = j;
                }
            }
            SortUtils.swap(a, i, min);
        }
```

那如果数据原本就是有序的呢？

比如:

> 7,1,2,3,4,5

在实际生活中，我们肯定是直接将7放在最后面：1,2,3,4,5,7，即可，但是如果使用选择排序就不行。因为它不知道有一段数据原本已经被排好序了。

有没有什么办法在循环过程中如果发现数据原本是有序的，那就**标记一下**，这样下次就可以不再对这段数据排序了呢？

#### 冒泡排序

冒泡排序非常简单，而且比较便于理解。核心便是两两比较，然后交换

假如有原始数据：

![image](/image/bubble/1.png)

然后将索引为**[0]**的元素与索引为**[1]**比较，发现7比1大，交换两者位置：

![image](/image/bubble/first.png)

继续将索引为**[1]**的元素与索引为**[2]**的元素进行比较，发现8比7大，不用交换：

![image](/image/bubble/third.png)

继续将索引为**[2]**的元素与索引为**[3]**的元素进行比较，发现8比3大，交换：

​						 ![image](/image/bubble/four.png)

继续将索引为**[3]**的元素与索引为**[4]**的元素进行比较，发现8比4大，交换：

![image](/image/bubble/five.png)

到这里，我们通过依次将 1与2 、 2与3、3与4、4与5**比较并交换**，将元素中最大的元素移动到了最后一个位子。我们可以利用这种规则，依次将第二大的元素，第三大的元素依次找出来。

在冒泡排序两两交换的过程中，正如上图中的橙色方块，承载的总是移动过程中遇到的最大的元素，通过这种方法**总是能找到比较大的元素然后向后移动，就好像水中的气泡一样，越来越大**，因此这种排序算法又称为冒泡排序。

代码如下：

```java
public class Bubble implements Sortable {
    @Override
    public void sort(int[] ints) {
        final int N = ints.length;
        //外层保证依次找到最大的元素
        for (int i = 0; i < N; i++) {
            //内层冒泡比较，将剩下最大元素移动到最后面
            for (int j = 0; j < N - i - 1; j++) {
                if (ints[j] > ints[j + 1]) {
                    SortUtils.swap(ints, j, j + 1);
                }
            }
        }
    }
}
```



-----

到这里，常规的冒泡排序已经说完，但是有些同学就会问了，这样算下来的时间复杂度好像还是**O(n^2)**啊，而且这个过程好像和选择排序没什么两样？只是寻找最大元素的方式变了而已，而且**冒泡排序还增加了交换次数**！

对，正因为寻找最大元素的方式变了，因此我们才有优化的可能。文章开头说道，如果我们能够对某个有序段进行标记，那么后面有序的元素都不用再次排序，可是最开始的冒泡排序似乎没有标记。

#### 冒泡排序再探

仔细观察冒泡排序的寻找最大元素的方式：**两两比较然后交换**。

这说明了：

- 每次循环过程中都会比较相邻的元素
- 如果两个元素不符合排序规则，则会被交换

> 不符合排序规则的元素，用官方的说法，叫做逆序，比如需要将元素由小到大排列，那么2,1 就称为一个逆序
>
> 那么冒泡排序的本质便是依次找到所有逆序，然后用交换的方式来消除逆序。

那如果在某次冒泡过程中，没有元素被交换呢？

那说明这段元素一定不存在逆序，并且元素都是按照由小到大排列好的。

因为如果这段元素存在逆序，那么根据冒泡排序的寻找最大值的方式来看，一定会发生元素交换。



因此，我们可以选取内层`for`循环的**最后一次交换的索引值**作为标记，索引值之后的元素一定是被排列好的。

比如有如下元素，我们使用四角星来标记发生最后一次交换的位置，默认在索引为[0]的位置：

![image](/image/bubble/11.png)

第一次：2与3比较，无需交换，比较的索引加一，标记不动：

![image](/image/bubble/22.png)

第二次：3与1比较，3大于1，需要交换，比较的索引加一，标记移动：

![image](/image/bubble/33.png)

第三次：3与7比较，无需交换和移动：

![image](/image/bubble/44.png)

第四次：7与8比较，无需交换和移动：

![image](/image/bubble/55.png)

到这里，第一轮排序完成，由于我们已经将标记放在了索引为[2]的地方，因此我们只需再拍前2个数即可，而后面的数是一定有序的。

第五次，比较2和1，交换：

![image](/image/bubble/66.png)

此时，标记为0，结束比较。



由上图我们可以发现，经过标记后的冒泡排序，节省了很多次无用的比较，而冒泡排序优化的本质便是：**利用数据原本的有序性**

接下来我们根据上面的图写出优化后的冒泡排序的代码：

```java
public class Bubble implements Sortable {   
    
    public void sort(int[] ints){
        final int N=ints.length;
        //初始化标志位
        for (int k=N-1;k>0;){
            //记录每次进行交换的位置
            int dis=0;
            //每次只遍历到标志位中
            for (int i=0;i<k;i++){
                if (ints[i]>ints[i+1]){
                    SortUtils.swap(ints,i,i+1);
                    dis=i;
                }
            }
            //循环完成后，将最后一次交换的索引的值赋给标志位
            k=dis;
        }
    }
}
```

代码比较简单，第一层`for`循环设置标志位，每次遍历只遍历到标志位即可，第二层循环两两比较即可。

### 时间复杂度

#### 普通冒泡排序

遍历时间：经过分析，普通的冒泡排序和选择排序差不多:

T=(n-1) + (n-2) + ... + 1=(n*(n-1))/2 ≈ O(n^2)

#### 优化版冒泡排序

经过优化版本的冒泡排序，所需要的时间复杂度和数组原本的顺序有关，如果数组原本有序，那么

T= n =O(n)，也就是经过一次遍历后便会将标志位置为0，从而结束循环

而最坏的情况下，也就是数组顺序和需要排序的顺序完全相反，那么时间复杂度和未优化的版本的是一样的，也就是T=O(n^2)



### 稳定性

我们可以发现，由于冒泡排序是两两比较，因此在发现两个相同的元素的时候，可以保持两个元素的相对位置不变，因此**冒泡排序是稳定的**



### 总结

冒泡排序的本质和选择排序差不多，不过冒泡排序可以通过优化而在某些情况下达到比较好的性能，而优化的途径便是**利用数据原本的有序性**

各个性能总结表格如下

|   版本   |       时间复杂度       | 空间复杂度 | 稳定性 |
| :------: | :--------------------: | :--------: | :----: |
| 未优化版 |      确定：O(n^2)      | 确定：O(1) |  稳定  |
|  优化版  | 最好：O(n)  最坏O(n^2) | 确定：O(1) |  稳定  |

 









